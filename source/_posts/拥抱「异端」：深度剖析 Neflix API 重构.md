---
title: '拥抱「异端」：深度剖析 Neflix API 重构'
date: 2018-03-15 10:20:28
tags: [架构设计]
---

_译者注：最近我们在改造自己的 API 架构过程中在爬文章时发现 Netflix 也曾经遇到了跟我们类似的问题：**一套 API 同时面向多类终端+多类型定制需求**。_

_其中 Neflix API 团队的解决方案与我们所设计的新架构有异曲同工之妙。也借此希望我们可以向国外技术大厂学习最前卫最酷的技术和解决方案，并取精用于解决我们自己遇到的问题。这也是我翻译这篇文章的主要原因。文中有部分内容纯属加戏，读原文可能会更容易理解作者本身设计方案时的哲学理念。_

_源文地址: https://medium.com/netflix-techblog/embracing-the-differences-inside-the-netflix-api-redesign-15fd8b3dc49d_

---

## 译文：

我在[之前的文章](https://blog.programmableweb.com/2012/05/15/why-rest-keeps-me-up-at-night/)提到过，团队发现传统的单体（one-size-fits-all ）OSFA REST API 架构存在明显的问题和不足，后来我们决定搞个牛逼的——完全定制化 API。作出这个决定的主要原因是 Neflix 的视频串流服务需要在超过800种不同的设备上运行，其中一大部分是使用私有 API 来接收内容传输的。虽然 OSFA API 也能很好地支持各种类型的终端设备，但我们强烈意识到不管是对我们的 API 团队、UI 团队还是观看视频内容的用户，这种解决方案都不是最优的。另外还考虑到 API 的使用者是一些我们都比较熟悉而且合作无间的开发者（基本都是 Netflix 内部的开发团队），因此我们就将原本的 「API」 发展成为「API 开发平台」。这个平台由几个哲学理念支撑着我们去设计这个新系统，它们分别是：

- 拥抱异端（Differences of the Devices，不同的终端，_译者注_）
- 分开处理内容的获取与分发
- 重新定义「客户端」与「服务端」的之间的界限
- 分布式创新

接下来我会逐一详细介绍这些思想，包括我们的实施过程以及从中获得的好处（和潜在的坏处）。不管怎么样，以上每一个条理念都反映了我们的终极目的：**尽一切可能向 Neflix 用户提供最大最好最棒的用户体验**。如果 API 与 UI 两者间的交互能力越高，我们就越有可能取悦用户。

好，哲学来了…

### 拥抱「异端」

这次重构 API 的关键驱动力就是我们得支撑 800 多种不同的终端。绝大部分 APIs（包括 Netflix 从2008年以来就一直使用的 REST API）都以相同的方式处理这些设备，这种方法有它本身的好处——单体 OSFA API 架构能让团队更容易地使各种 API 被消费得更高效、稳定，因为是由 API 开发团队自己负责制定的规则，其他人（API 消费者）只能乖乖遵循、默默敲代码。

但其实不同的设备需要不同的优化方案，也正是由于这种差异性我们才能得以在不同的设备上拥有最佳的用户体验。OSFA 却偏偏忽略了这一点。即使这种架构是高效可用的，**OSFA 的重点是对于 API 提供方很方便，但对消费方却会很蛋疼**。看完以下这些差异点你就明白为什么了：

- 内存和处理器的性能差异可能会影响在给定时间内处理数据的能力
- Requirements for distinct markup formats and broader device proliferation increases the likelihood of this（没懂 _译者注_）
- 文件模型  （跟 DOM 有关系吗？ _译者注_），有的设备在扁平化的模型上运作得好，有的却在更结构化的文件模型上运作得好
- 屏幕的大小、像素也会影响内容处理的方式
- 文件传输，有的用 HTTP 协议逐步串流比较好，有的直接处理完整的文件比较好
- 用户交互（UI），可能会影响元数据字段，传输方式，交互模型等等

我们希望消除这种对差异化一视同仁的处理方式，从而设计出一种可以接受并支持各种定制化的新模式。为此，我们的 API 开发平台允许每个前端团队自己去创建自己的接口 endpoint，从而去根据每个前端团队去优化不同的「请求返回模型（request/response model）」，以满足在不同设备上的各种奇葩不同设备的前端定制需求。为了支持这些多样化的「请求返回模型」，我们需要一种不同的架构，其中为我们带来了另一个哲学理念…

### 分开处理内容的获取与分发

在很多 OSFA 的实际运用中，一个 API 通常是先从数据资源中获取原始内容，并将内容封装好，最后再分发。从前 Netflix REST API 也是以这种方式运作的，类似于下图：

![](https://fargogo.oss-cn-shanghai.aliyuncs.com/cdn/1.png)

举个栗子，上图中的那台 PS3 游戏机需要向 REST API 服务做出一大堆请求来完成一个动作——启动 Neflix。其它设备也是用类似的方式去调用 OSFA REST API 的，这里的每个 REST API 对这些请求调用都同时做了收集、封装、分发这几种处理。

我们新的 API 已经脱离了 OSFA 模式，转而使用粒度更细、定制化更强而不会影响整个系统的可控性的新模式。为此，我们的新架构很清晰的拆分成了内容收集、封装和分发三个部分。如下图：

![](https://fargogo.oss-cn-shanghai.aliyuncs.com/cdn/2.png)

我可以看到，前端的请求只指向了一个端口去调用一次定制化的、被特殊设计过的接口入口端。入口端的背后是一个被称为「Java API」的请求解析器，用于回调一系列的相关服务和数据资源调用。我们会在后面详细介绍这一块是怎么做的，特别是我们怎么解析接口、触发调用依赖、处理并发、回退支持和一些其它的用于优化及保证获取正确内容的技术。但现在我只能说，在内容获取上 Java API 这块依然是一个通用的模块，与资源本身是独立开的，和 OSFA 没有本质区别。

在内容被成功获取后会被交到 Java API 顶层的内容封装、传输引擎中处理，如图所示，Java API 上以另一个小的设备列表来表示这个结构，每个小设备代表着针对这个设备定制过的接口入口。「定制化接口入口」（customized endpoints）什么鬼？就像前文提到过的，用于针对特定设备的请求、返回的优化处理模块，下一个哲学理念，走你…

### 重新定义「客户端」与「服务端」之间的界限

在传统的思想中，「客户端代码」一般都指运行在终端设备上的代码或者「UI 前端代码」，而「服务端代码」一般指在服务器上运行的代码。「网络边界（network border）」即区分它们两者间的边界。这条边界也是在 REST APIs 架构中位于 API 提供方及消费方之间互想遵守的约定，Netflix 以前也这么干的，如下图：

![](https://fargogo.oss-cn-shanghai.aliyuncs.com/cdn/3.png)

在我们的新方案中，我们把这条边界向服务器那层推回去了，并且用相当一部分来执行对 UI 的特定内容处理。所有终端设备上的代码依然视为「客户端代码」，但是现在我们把一部分的客户端代码移到了服务器上。

本质上，客户端是向服务端上的适配器（用 Groovy 写的）上的一个定制化接口发了个网络请求。当请求发送到该适配器服务后，这个适配器会将这个一个请求拆开成 N 个对服务器后端的请求，以获取相应的内容。在这个时候，Java APIs 将执行内容收集功能并将相应的内容分发回适配器中；适配器一旦接收到所有或其中的一部分内容后，就会开始对内容进行数据清洗、错误捕获、错误处理、格式化返回内容以及将文件头和文件主体完整的分发出去等步骤。整个处理过程都是为某个前端设备度身定制过的，下图完美的展示了这种新的对客户端/服务端的定义：

![](https://fargogo.oss-cn-shanghai.aliyuncs.com/cdn/4.png)

这里有两个部分的改变：第一，从前需要向网络发送的一大坨请求现在可以在服务端上处理了，使得设备和服务器之间的交互更有效率，原因很简单，网络请求的是数据交换中最昂贵的一部分，所以[降低网络请求数量](https://medium.com/@Netflix_Techblog/redesigning-the-netflix-api-db5a7221fcff)即提升了性能，这个过程有时候是几秒钟呢。第二个改变正好引出最后一个哲学理念（可能是最重要的）。

### 分布式创新

在这次改造中，其中一个争议点是一旦我们以后新增了很多设备支持或者需要做超多前端 A/B 测试的话，毫无疑会带来关于如何有效管理、配置无数个适配器的问题。我们该如何快速创建并及维护这么多（且不停增长）的适配器组件呢？的确，可以支持自定义适配器对我们来说是必不可少的，但同样地，如何在这些不同的 UI 和设备上保持高速创新也同样非常重要。

如上文所说，将部分客户端代码向服务端移植并支持自定义创建端口给了我们一个**将接口开发任务交给前端**的机会。我们得以这么做是因为这些私有 API 的消费者是 Neflix 自己的 UI 及设备团队。他们可以自主的维护更新他们自己的适配器上的代码（这个过程基本上不需要任何 API 开发团的人员参与），他们可以更灵活敏捷地关注于自己手上的开发任务上。也就是说，只要 Java API 上提供了有效的内容接口，前端们就可以针对他们手头上的设备做最大化的优化工作。与此同时，他们可以根据用户需求对内容按照需求自己封装来提升用户体验。他们也不再需要和后端团队绑死在一起，更不需要因为后端接口的种种限制成为开发瓶颈。API 的创新工作现在已经交到了前端团队手上了！还有，因为这些适配器是互相独立的，几乎不可能出现因为 API 的迭代会影响到其它设备的兼容问题，反正，你爱怎么弄，就怎么弄。

当然了，这里引出了个需要忧虑的点是，通常前端团队比较熟悉类似 HTML5、CSS3、JavaScript 等技术。在此系统中，他们现在需要学习一些后端技术了。不过目前看来对我们来说这还只是个小 case，因为[我们的工程师文化是只招大牛](https://www.slideshare.net/reed2001/culture-1798664?ref=https://jobs.netflix.com/jobs.html)，特别是那些**适应力强**、**好奇心重**以及对**如何解决问题充满激情**的人。另外还有一个我们担心的点是，因为前端团队需要在服务端开发，有时可能会不小心搞了个无限循环或者不小心一下抓了一大坨量的数据进而把机子搞宕掉。为了弥补这个风险，我们正在研究「清洗引擎 scrubbing engines」，希望尽量减少出现这些错误的可能性。这么说吧，在 OSFA 中，设备上的代码可以像服务器一样容易 DDOS，但如果它在服务器上运行，它可能会是一个更大的潜在问题。

### 栗子:

1. 现在有台 PS3 游戏机，发送了**一个**网络请求去加载首页（PS3 UI 团队负责维护的）。
1. 用 Groovy 写适配器接受并解释了这个请求（PS3 UI 团）
1. 适配器将这个请求拆成 N 个请求去调用 Java API （PS3 UI 团）
1. 每个 Java API 请求都会在适当的时候调用背后的依赖服务以获取用于调用子级请求（API 团）
1. 在调用 Java API 的过程中，依赖服务不可用或返回4xx或者5xx的错误，Java API 会返回「回退」并且/或者返回错误码给到适配器（API 团）
1. 要是 Java API 成功获取到数据内容，就会在所有线程完成后将内容丢给适配器（API 团）
1. 适配器可以从不同的线程中逐步（或全部）获取返回的内容，看 UI 团喜欢（UI 团）
1. 接着适配器就开始处理内容，把需要的东西抽出来（不要的就扔掉）、处理错误什么的（UI 团）
1. 适配器将返回结果根据加载首页这个请求所需要的数据封装好后（UI 团）
1. 最后适配器将这个封装好的数据包，通过网络返回给 PS3（UI 团）
1. 游戏机拿到这些通过优化的数据后完美的在前端展示出来，voila（UI 团）

对于现在这个新系统我们的进度还是在初期，有的设备终端已经完全迁移过去了，有一些新/旧两种同时在用，还有些才刚开始。

在未来的文章里，我们会分享一些关于这个系统更深入的技术，包括如何处理并发、如何管理适配器、适配器与 Java API 的交互方式、Groovy 的应用、错误处理等等。我们也会将我们继续分享系统的进一步发展和演变，也希望我们会随之共同学到更多。

对了，你要是对构建类似于这种大规模、基于云的解决方案也有兴趣，来来来，法狗狗欢迎你哦！

_源标题：**Embracing the Differences : Inside the Netflix API Redesign**_
_原作者：Daniel Jacobson ([@daniel_jacobson](https://www.twitter.com/daniel_jacobson)), Director of Engineering — Netflix API_

_译者：Time, Tech Lead —Fagougou.com_
